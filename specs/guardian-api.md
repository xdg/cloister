# Guardian API Reference

The guardian system exposes five interfaces:

| Interface | Binding | Purpose | Clients |
|-----------|---------|---------|---------|
| Proxy (:3128) | `cloister-net` | HTTP CONNECT proxy | Containers |
| Token API (:9997) | `127.0.0.1` | Token registration and management | CLI on host |
| Request Server (:9998) | `cloister-net` | Command execution requests | Containers (hostexec) |
| Approval Server (:9999) | `127.0.0.1` | Web UI and API for human review | Host only |
| Host Executor (TCP) | `host.docker.internal:<port>` | Command execution on host | Guardian container only |

The first four run in the guardian container. The host executor runs as a separate process on the host, communicating with the guardian via TCP (using Docker's `host.docker.internal` hostname).

For architecture overview, see [cloister-spec.md](cloister-spec.md).

---

## Authentication

### Cloister Token

All container-facing endpoints require authentication using the cloister token. The token is:

- Generated by the CLI (32 bytes, hex-encoded) when creating a cloister
- Passed to the container via `CLOISTER_TOKEN` environment variable
- Registered with the guardian before the container starts
- The sole source of cloister identity (body fields are informational only)

**Authentication methods by endpoint:**

| Endpoint | Method | Rationale |
|----------|--------|-----------|
| Proxy (:3128) | `Proxy-Authorization` header | Standard mechanism; works with all HTTP clients |
| Request server (:9998) | `X-Cloister-Token` header | Custom header for JSON API |

The proxy uses standard HTTP proxy authentication because custom headers on CONNECT requests aren't supported by most HTTP clients. The container's proxy URL includes credentials:

```bash
HTTPS_PROXY=http://cloister:${CLOISTER_TOKEN}@cloister-guardian:3128/
HTTP_PROXY=http://cloister:${CLOISTER_TOKEN}@cloister-guardian:3128/
NO_PROXY=cloister-guardian,localhost,127.0.0.1
```

Requests without valid credentials are rejected with 401 Unauthorized (proxy) or 407 Proxy Authentication Required.

### Guardian↔Executor Secret

The TCP connection for host command execution requires a shared secret between the guardian container and the host executor process. This prevents unauthorized processes from executing commands via the executor port.

The secret is:

- Generated by the CLI (32 bytes, hex-encoded) when starting the guardian
- Passed to the guardian container via environment variable
- Passed to the host executor process via command-line flag or environment
- Ephemeral: never written to disk, dies when guardian stops

This provides defense-in-depth: even if an attacker obtains a cloister token (e.g., by reading token files), they cannot execute commands without the guardian secret.

---

## Token API Endpoints (:9997)

Internal API for token management. Bound to `127.0.0.1` only. Only accessible from the host CLI.

### POST /tokens

Register a new cloister token. Called by the CLI before starting a container.

**Request:**
```json
{
    "token": "af3b2c1d...",
    "cloister": "my-api-main",
    "project": "my-api",
    "worktree": "/home/user/repos/my-api"
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `token` | Yes | The cloister token (32 bytes, hex-encoded) |
| `cloister` | Yes | The cloister container name |
| `project` | No | The project name |
| `worktree` | No | The worktree path on the host |

**Response (201 Created):**
```json
{
    "status": "registered"
}
```

### DELETE /tokens/{token}

Revoke a cloister token. Called by the CLI when stopping a container.

**Response (200 OK):**
```json
{
    "status": "revoked"
}
```

**Response (404 Not Found):**
```json
{
    "error": "token not found"
}
```

### GET /tokens

List all registered tokens. Useful for debugging and monitoring.

**Response:**
```json
{
    "tokens": [
        {
            "token": "af3b2c1d...",
            "cloister": "my-api-main",
            "project": "my-api",
            "worktree": "/home/user/repos/my-api"
        }
    ]
}
```

---

## Proxy Endpoint (:3128)

Standard HTTP CONNECT proxy for HTTPS traffic.

**Authentication:** `Proxy-Authorization` header (Basic auth with token as password)

**Behavior:**
- Domain checked against allowlist (global + project-specific)
- Allowed domains: connection forwarded
- Unlisted domains: behavior depends on `unlisted_domain_behavior` config
  - `request_approval`: Hold connection, create approval request, wait up to 60s
  - `reject`: Immediately return 403

**Error response (blocked domain):**
```
HTTP/1.1 403 Forbidden
Content-Type: application/json

{"error": "domain not in allowlist", "domain": "evil.com"}
```

---

## Request Server Endpoints (:9998)

Exposed on `cloister-net`. Only containers should connect here.

### POST /request

Submit a command for approval. Blocks until the command is approved/denied and executed.

**Headers (required):**
```
X-Cloister-Token: <token>
```

The token is the sole source of cloister identity. The guardian looks up cloister metadata (name, project, branch) from its token registry.

**Request fields:**

| Field | Required | Description |
|-------|----------|-------------|
| `cmd` | Yes | Human-readable command string for pattern matching and display |
| `args` | Yes | Tokenized argument array for execution (`args[0]` is the command) |

The `cmd` field is used for pattern matching and human review. The `args` array is used for actual execution via `exec` (no shell), preventing shell injection attacks. The shell has already tokenized the arguments, so we preserve that tokenization.

**Request body:**
```json
{
    "cmd": "docker compose up -d",
    "args": ["docker", "compose", "up", "-d"]
}
```

**Response (auto-approved):**
```json
{
    "status": "auto_approved",
    "pattern": "^docker compose ps$",
    "exit_code": 0,
    "stdout": "NAME       STATUS    PORTS\ndb         running   5432/tcp",
    "stderr": ""
}
```

**Response (manually approved):**
```json
{
    "status": "approved",
    "exit_code": 0,
    "stdout": "Container my-api-db-1  Started",
    "stderr": ""
}
```

**Response (denied, rejected by user):**
```json
{
    "status": "denied",
    "reason": "Command denied by user"
}
```

**Response (denied, no rule match):**
```json
{
    "status": "denied",
    "reason": "Command doesn't match allowlist"
}
```

**Response (timeout):**
```json
{
    "status": "timeout",
    "reason": "No approval within 5m0s"
}
```

---

## Approval Server Endpoints (:9999)

Bound to `127.0.0.1` only. Only accessible from the host.

### GET /

Web UI (HTML served directly) showing all cloisters and pending requests.

### GET /pending

List pending command approval requests.

**Response:**
```json
{
    "requests": [
        {
            "id": "abc123",
            "cloister": "my-api-main",
            "project": "my-api",
            "branch": "main",
            "agent": "claude",
            "cmd": "docker compose up -d",
            "timestamp": "2024-01-15T14:32:05Z"
        },
        {
            "id": "def456",
            "cloister": "frontend-feature-auth",
            "project": "frontend",
            "branch": "feature-auth",
            "agent": "codex",
            "cmd": "gh pr create --title 'Add auth'",
            "timestamp": "2024-01-15T14:32:10Z"
        }
    ]
}
```

### POST /approve/{id}

Approve a pending command request. Triggers command execution on host; result flows back to request server.

**Response:**
```json
{
    "status": "approved",
    "id": "abc123"
}
```

### POST /deny/{id}

Deny a pending command request with optional reason.

**Request (optional):**
```json
{
    "reason": "Package not needed"
}
```

**Response:**
```json
{
    "status": "denied",
    "id": "abc123"
}
```

### GET /events

Server-Sent Events (SSE) endpoint for real-time updates. Used by the web UI to receive live notifications when requests are added or removed from the queue.

**Event types:**
- `request-added` — A new request was added to the queue
- `request-removed` — A request was approved, denied, or timed out
- `heartbeat` — Keep-alive message (sent every 30 seconds)

**Headers:**
```
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
```

### GET /static/*

Serves static assets (CSS, JavaScript) for the web UI. These assets are embedded in the binary via `go:embed`.

### GET /pending-domains (Planned)

List pending domain approval requests. *Not yet implemented.*

**Response (planned):**
```json
{
    "requests": [
        {
            "id": "xyz789",
            "cloister": "my-api-main",
            "project": "my-api",
            "domain": "docs.example.com",
            "timestamp": "2024-01-15T14:32:05Z",
            "expires": "2024-01-15T14:33:05Z"
        }
    ]
}
```

### POST /approve-domain/{id} (Planned)

Approve a pending domain request with specified scope. *Not yet implemented.*

**Request (planned):**
```json
{
    "scope": "project"
}
```

Scope options:
- `"session"` — Allow for this cloister session only (in-memory, expires on stop)
- `"project"` — Save to `~/.config/cloister/projects/<name>.yaml`
- `"global"` — Save to `~/.config/cloister/config.yaml`

### POST /deny-domain/{id} (Planned)

Deny a pending domain request. *Not yet implemented.*

### GET /logs?cloister={name} (Planned)

Stream audit logs, optionally filtered by cloister. *Not yet implemented.*

---

## Host Executor

TCP server on localhost (random port). The executor port is passed to the guardian container via `CLOISTER_EXECUTOR_PORT` environment variable. The guardian connects to `host.docker.internal:<port>` to send approved commands for execution on the host.

### Connection Model

Connection-per-request: guardian opens a new connection for each command, sends request, receives response, closes connection. This naturally multiplexes concurrent requests from different cloisters without request ID correlation.

```
Guardian                    Executor
   |                           |
   |--[connect]--------------->|
   |--{request JSON}\n-------->|  (goroutine spawned)
   |<--{response JSON}\n-------|
   |--[close]----------------->|
```

### Wire Format

Newline-delimited JSON (one object per line). Newlines within string values must be `\n` escaped.

### Execute Command

**Request:**
```json
{
    "secret": "e7f2a1b9c4d8...",
    "request": {
        "command": "docker",
        "args": ["compose", "up", "-d"],
        "workdir": "/home/user/repos/my-api",
        "env": {"DOCKER_HOST": "unix:///var/run/docker.sock"},
        "timeout_ms": 300000
    }
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `secret` | Yes | Guardian↔executor shared secret |
| `request.command` | Yes | Executable name or path (no shell expansion) |
| `request.args` | No | Arguments array (default: empty) |
| `request.workdir` | No | Working directory for command execution |
| `request.env` | No | Environment overrides (merged with host environment) |
| `request.timeout_ms` | No | Execution timeout in milliseconds (default: 300000 = 5 min) |

**Validation order:**
1. Verify `secret` matches executor's secret → reject if mismatch
2. Execute command via `exec` (no shell)

Token validation is handled by the guardian before forwarding requests to the executor. The executor trusts requests with valid shared secrets.

Using `command` + `args` instead of a shell command string prevents shell injection. If shell features are needed, the approved command must explicitly be `["sh", "-c", "..."]`.

**Response (success):**
```json
{
    "status": "completed",
    "exit_code": 0,
    "stdout": "Container my-api-db-1  Started\n",
    "stderr": ""
}
```

**Response (invalid secret):**
```json
{
    "status": "error",
    "error": "invalid secret"
}
```

**Response (timeout):**
```json
{
    "status": "timeout",
    "exit_code": -1,
    "stdout": "partial output...",
    "stderr": ""
}
```

**Response (execution error):**
```json
{
    "status": "error",
    "error": "exec: \"nonexistent\": executable file not found in $PATH"
}
```
