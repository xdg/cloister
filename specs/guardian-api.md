# Guardian API Reference

The guardian system exposes five interfaces:

| Interface | Binding | Purpose | Clients |
|-----------|---------|---------|---------|
| Proxy (:3128) | `cloister-net` | HTTP CONNECT proxy | Containers |
| Token API (:9997) | `127.0.0.1` | Token registration and management | CLI on host |
| Request Server (:9998) | `cloister-net` | Command execution requests | Containers (hostexec) |
| Approval Server (:9999) | `127.0.0.1` | Web UI and API for human review | Host only |
| Host Executor (TCP) | `host.docker.internal:<port>` | Command execution on host | Guardian container only |

The first four run in the guardian container. The host executor runs as a separate process on the host, communicating with the guardian via TCP (using Docker's `host.docker.internal` hostname).

For architecture overview, see [cloister-spec.md](cloister-spec.md).

---

## Authentication

### Cloister Token

All container-facing endpoints require authentication using the cloister token. The token is:

- Generated by the CLI (32 bytes, hex-encoded) when creating a cloister
- Passed to the container via `CLOISTER_TOKEN` environment variable
- Registered with the guardian before the container starts
- The sole source of cloister identity (body fields are informational only)

**Authentication methods by endpoint:**

| Endpoint | Method | Rationale |
|----------|--------|-----------|
| Proxy (:3128) | `Proxy-Authorization` header | Standard mechanism; works with all HTTP clients |
| Request server (:9998) | `X-Cloister-Token` header | Custom header for JSON API |

The proxy uses standard HTTP proxy authentication because custom headers on CONNECT requests aren't supported by most HTTP clients. The container's proxy URL includes credentials:

```bash
HTTPS_PROXY=http://cloister:${CLOISTER_TOKEN}@cloister-guardian:3128/
HTTP_PROXY=http://cloister:${CLOISTER_TOKEN}@cloister-guardian:3128/
NO_PROXY=cloister-guardian,localhost,127.0.0.1
```

Requests without valid credentials are rejected with 401 Unauthorized (proxy) or 407 Proxy Authentication Required.

### Guardianâ†”Executor Secret

The TCP connection for host command execution requires a shared secret between the guardian container and the host executor process. This prevents unauthorized processes from executing commands via the executor port.

The secret is:

- Generated by the CLI (32 bytes, hex-encoded) when starting the guardian
- Passed to the guardian container via environment variable
- Passed to the host executor process via command-line flag or environment
- Ephemeral: never written to disk, dies when guardian stops

This provides defense-in-depth: even if an attacker obtains a cloister token (e.g., by reading token files), they cannot execute commands without the guardian secret.

---

## Token API Endpoints (:9997)

Internal API for token management. Bound to `127.0.0.1` only. Only accessible from the host CLI.

### POST /tokens

Register a new cloister token. Called by the CLI before starting a container.

**Request:**
```json
{
    "token": "af3b2c1d...",
    "cloister": "my-api-main",
    "project": "my-api",
    "worktree": "/home/user/repos/my-api"
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `token` | Yes | The cloister token (32 bytes, hex-encoded) |
| `cloister` | Yes | The cloister container name |
| `project` | No | The project name |
| `worktree` | No | The worktree path on the host |

**Response (201 Created):**
```json
{
    "status": "registered"
}
```

### DELETE /tokens/{token}

Revoke a cloister token. Called by the CLI when stopping a container.

**Response (200 OK):**
```json
{
    "status": "revoked"
}
```

**Response (404 Not Found):**
```json
{
    "error": "token not found"
}
```

### GET /tokens

List all registered tokens. Useful for debugging and monitoring.

**Response:**
```json
{
    "tokens": [
        {
            "token": "af3b2c1d...",
            "cloister": "my-api-main",
            "project": "my-api",
            "worktree": "/home/user/repos/my-api"
        }
    ]
}
```

---

## Proxy Endpoint (:3128)

Standard HTTP CONNECT proxy for HTTPS traffic.

**Authentication:** `Proxy-Authorization` header (Basic auth with token as password)

**Behavior:**
- Domain checked against allowlist (global + project-specific)
- Allowed domains: connection forwarded
- Unlisted domains: behavior depends on `unlisted_domain_behavior` config
  - `request_approval`: Hold connection, create approval request, wait up to 60s
  - `reject`: Immediately return 403

**Error response (blocked domain):**
```
HTTP/1.1 403 Forbidden
Content-Type: application/json

{"error": "domain not in allowlist", "domain": "evil.com"}
```

---

## Request Server Endpoints (:9998)

Exposed on `cloister-net`. Only containers should connect here.

### POST /request

Submit a command for approval. Blocks until the command is approved/denied and executed.

**Headers (required):**
```
X-Cloister-Token: <token>
```

The token is the sole source of cloister identity. The guardian looks up cloister metadata (name, project, branch) from its token registry.

**Request fields:**

| Field | Required | Description |
|-------|----------|-------------|
| `args` | Yes | Tokenized argument array for execution and pattern matching (`args[0]` is the command) |
| `cmd` | No | **DEPRECATED.** Ignored by the server. Kept for backwards compatibility. |

The `args` array is the authoritative source for both pattern matching and execution. The guardian reconstructs a canonical command string from `args` using shell quoting rules:

- Simple args (alphanumeric, `-_./:@+=`): used as-is
- Args with spaces or special characters: wrapped in single quotes
- Embedded single quotes: escaped using the POSIX `'\''` idiom

This prevents a security vulnerability where a malicious `cmd` could pass pattern validation while `args` executes something different.

**Validation:** Arguments containing NUL bytes (`\x00`) are rejected with a 400 Bad Request error, as NUL bytes cannot be safely represented in shell commands.

**Request body:**
```json
{
    "args": ["docker", "compose", "up", "-d"]
}
```

**Response (auto-approved):**
```json
{
    "status": "auto_approved",
    "pattern": "^docker compose ps$",
    "exit_code": 0,
    "stdout": "NAME       STATUS    PORTS\ndb         running   5432/tcp",
    "stderr": ""
}
```

**Response (manually approved):**
```json
{
    "status": "approved",
    "exit_code": 0,
    "stdout": "Container my-api-db-1  Started",
    "stderr": ""
}
```

**Response (denied, rejected by user):**
```json
{
    "status": "denied",
    "reason": "Command denied by user"
}
```

**Response (denied, no rule match):**
```json
{
    "status": "denied",
    "reason": "Command doesn't match allowlist"
}
```

**Response (timeout):**
```json
{
    "status": "timeout",
    "reason": "No approval within 5m0s"
}
```

---

## Approval Server Endpoints (:9999)

Bound to `127.0.0.1` only. Only accessible from the host.

### GET /

Web UI (HTML served directly) showing all cloisters and pending requests.

### GET /pending

List pending command approval requests.

**Response:**
```json
{
    "requests": [
        {
            "id": "abc123",
            "cloister": "my-api-main",
            "project": "my-api",
            "branch": "main",
            "agent": "claude",
            "cmd": "docker compose up -d",
            "timestamp": "2024-01-15T14:32:05Z"
        },
        {
            "id": "def456",
            "cloister": "frontend-feature-auth",
            "project": "frontend",
            "branch": "feature-auth",
            "agent": "codex",
            "cmd": "gh pr create --title 'Add auth'",
            "timestamp": "2024-01-15T14:32:10Z"
        }
    ]
}
```

Note: The `cmd` field in pending requests is the canonical command string reconstructed from `args` using shell quoting. Arguments containing spaces or special characters are single-quoted (e.g., `echo 'hello world'`).
```

### POST /approve/{id}

Approve a pending command request. Triggers command execution on host; result flows back to request server.

**Response:**
```json
{
    "status": "approved",
    "id": "abc123"
}
```

### POST /deny/{id}

Deny a pending command request with optional reason.

**Request (optional):**
```json
{
    "reason": "Package not needed"
}
```

**Response:**
```json
{
    "status": "denied",
    "id": "abc123"
}
```

### GET /events

Server-Sent Events (SSE) endpoint for real-time updates. Used by the web UI to receive live notifications when requests are added or removed from the queue.

**Event types:**
- `request-added` â€” A new request was added to the queue
- `request-removed` â€” A request was approved, denied, or timed out
- `heartbeat` â€” Keep-alive message (sent every 30 seconds)

**Headers:**
```
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
```

### GET /static/*

Serves static assets (CSS, JavaScript) for the web UI. These assets are embedded in the binary via `go:embed`.

### GET /pending-domains

List pending domain approval requests.

**Response:**
```json
{
    "requests": [
        {
            "id": "xyz789",
            "cloister": "my-api-main",
            "project": "my-api",
            "domain": "docs.example.com",
            "timestamp": "2024-01-15T14:32:05Z",
            "expires": "2024-01-15T14:33:05Z"
        }
    ]
}
```

### POST /approve-domain/{id}

Approve a pending domain request with specified scope and optional wildcard pattern.

**Request:**
```json
{
    "scope": "project",
    "wildcard": false
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `scope` | Yes | string | Persistence scope (see below) |
| `wildcard` | No | bool | If true, approve `*.domain.com` pattern instead of exact domain. Default: false |

**Scope options:**
- `"once"` â€” Forward this request only, don't add to any allowlist (stateless approval)
- `"session"` â€” Add to in-memory allowlist, expires when cloister stops
- `"project"` â€” Persist to `~/.config/cloister/decisions/projects/<name>.yaml` under `proxy.allow`
- `"global"` â€” Persist to `~/.config/cloister/decisions/global.yaml` under `proxy.allow`

**Wildcard behavior:**
- If `wildcard: true` and domain is `api.example.com`, the pattern `*.example.com` is added to the appropriate allowlist
- Wildcard patterns match one subdomain level: `*.example.com` matches `api.example.com` but NOT `api.v2.example.com`
- The pattern `*.example.com` also matches the apex domain `example.com` for convenience
- Both wildcard patterns (as `pattern:` entries) and exact domains (as `domain:` entries) are stored in the `proxy.allow` or `proxy.deny` list

**Response:**
```json
{
    "status": "approved",
    "scope": "project",
    "pattern": "*.example.com"
}
```

| Field | Description |
|-------|-------------|
| `status` | Always `"approved"` for success |
| `scope` | Echo of requested scope |
| `pattern` | If wildcard was used, the resulting pattern; otherwise omitted |
| `persistence_error` | If config write failed, error message (domain still approved for session) |

### POST /deny-domain/{id}

Deny a pending domain request with specified scope and optional wildcard pattern.

**Request:**
```json
{
    "scope": "project",
    "wildcard": false
}
```

| Field | Required | Type | Description |
|-------|----------|------|-------------|
| `scope` | Yes | string | Persistence scope (see below) |
| `wildcard` | No | bool | If true, deny `*.domain.com` pattern instead of exact domain. Default: false |

**Scope options:**
- `"once"` â€” Reject this request only, don't add to any denylist (stateless denial)
- `"session"` â€” Add to in-memory denylist, expires when cloister stops
- `"project"` â€” Persist to `~/.config/cloister/decisions/projects/<name>.yaml` under `proxy.deny`
- `"global"` â€” Persist to `~/.config/cloister/decisions/global.yaml` under `proxy.deny`

**Precedence:** Denials override approvals at all scope levels. If a domain appears in both allowlist and denylist, it's blocked.

**Wildcard behavior:** Same semantics as approval endpoint â€” `*.example.com` blocks all subdomains and apex.

**Response:**
```json
{
    "status": "denied",
    "scope": "project",
    "pattern": "*.sketchy.io"
}
```

| Field | Description |
|-------|-------------|
| `status` | Always `"denied"` for success |
| `scope` | Echo of requested scope |
| `pattern` | If wildcard was used, the resulting pattern; otherwise omitted |
| `persistence_error` | If config write failed, error message (domain still denied for session) |

### GET /logs?cloister={name} (Planned)

Stream audit logs, optionally filtered by cloister. *Not yet implemented.*

---

## Web UI

The approval server at `http://localhost:9999` provides a web interface for reviewing and approving agent requests in real-time. The UI is a single-page application with vanilla JavaScript and Server-Sent Events (SSE) for live updates.

### Overview

**URL:** `http://localhost:9999/`

The main dashboard shows:
- **Pending Requests** â€” Chronological list of all pending requests (commands and domains mixed)
  - Each request card shows type (command/domain), cloister, timestamp, and decision buttons
  - Most recent requests appear first
- **Recent Decisions** â€” Last 10 approvals/denials with timestamps and scope

**Connection status:** Banner at top shows connectivity state:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âš  Connection lost - Reconnecting...              [Retry]   â”‚  â† Yellow banner
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```
Or when guardian is offline:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ— Cannot connect to guardian - Is it running?    [Retry]   â”‚  â† Red banner
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Real-time updates:** The UI connects to `/events` (SSE) to receive notifications when:
- New requests are added to the queue
- Requests are approved, denied, or time out
- Connection to guardian is lost or restored

### Pending Requests

All pending requests appear in a single chronological list, with the most recent at the top. Each request card shows its type (command or domain) along with relevant details.

**Command request card:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ”§ COMMAND REQUEST                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Cloister:  my-api-main                                      â”‚
â”‚ Command:   docker compose up -d                             â”‚
â”‚ Time:      14:32:05 (expires in 4m 32s)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [ Approve ]  [ Deny ]                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Approval flow:**
1. Click **Approve** â†’ Command executes on host, output streams back to agent
2. Click **Deny** â†’ Optional reason modal, then 403 error returned to agent
3. Timeout (5 minutes) â†’ Automatic denial, agent receives timeout error

**After decision:**
- Request card removed from queue
- Confirmation banner: `âœ“ Approved: docker compose up -d`
- Output streaming (if approved): Real-time stdout/stderr display

**Domain request card:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸŒ DOMAIN REQUEST                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Cloister:  my-api-main                                      â”‚
â”‚ Domain:    api.newservice.com                               â”‚
â”‚ Time:      14:33:00 (expires in 58s)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [âœ“] Apply to wildcard pattern: *.newservice.com            â”‚
â”‚                                                             â”‚
â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â• ALLOW â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—                      â”‚
â”‚ â•‘ [ Once ] [ Session ] [ Project ] [ Global ] â•‘            â”‚
â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                      â”‚
â”‚                                                             â”‚
â”‚ â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â• DENY â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—                      â”‚
â”‚ â•‘ [ Once ] [ Session ] [ Project ] [ Global ] â•‘            â”‚
â”‚ â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Decision options:**

| Action | Scope | Description | Persisted To |
|--------|-------|-------------|--------------|
| **Allow** | Once | Forward this request only | None (stateless) |
| | Session | Allow until cloister stops | In-memory cache |
| | Project | Allow for all cloisters in this project | `~/.config/cloister/decisions/projects/<name>.yaml` |
| | Global | Allow for all projects | `~/.config/cloister/decisions/global.yaml` |
| **Deny** | Once | Reject this request only | None (stateless) |
| | Session | Block until cloister stops | In-memory denylist |
| | Project | Block for all cloisters in this project | `~/.config/cloister/decisions/projects/<name>.yaml` |
| | Global | Block for all projects | `~/.config/cloister/decisions/global.yaml` |

**Wildcard checkbox:**
- When checked, decision applies to `*.newservice.com` instead of exact domain `api.newservice.com`
- Matches one subdomain level: `*.example.com` matches `api.example.com` but NOT `api.v2.example.com`
- Also matches apex domain: `*.example.com` matches `example.com`
- Useful for CDNs, API gateways, multi-region services

**Approval flow:**
1. Agent requests `api.newservice.com`
2. Proxy holds connection open (60s timeout)
3. Request appears in UI with all decision options
4. User clicks button (e.g., **Allow â†’ Project**)
5. UI sends POST to `/approve-domain/{id}` with `{"scope": "project", "wildcard": false}`
6. Backend adds domain to `~/.config/cloister/decisions/projects/my-api.yaml` under `proxy.allow`
7. Proxy forwards request to upstream server
8. UI shows confirmation, e.g:
   ```
   âœ“ Allowed api.newservice.com (project scope)
   Request forwarded to agent.
   ```

**Denial flow:**
1. Same steps 1-4 as approval
2. User clicks button (e.g., **Deny â†’ Global**)
3. UI sends POST to `/deny-domain/{id}` with `{"scope": "global", "wildcard": false}`
4. Backend adds domain to `~/.config/cloister/decisions/global.yaml` under `proxy.deny`
5. Proxy returns 403 Forbidden to agent
6. UI shows confirmation, e.g.:
   ```
   âœ— Blocked api.newservice.com (global scope)
   All future requests to this domain will be denied.
   ```

**Wildcard example:**
- Domain: `assets.cdn.example.com`
- Checkbox: âœ“ Apply to wildcard pattern
- Click: **Allow â†’ Project**
- Result: Adds `*.cdn.example.com` to `proxy.allow` in project decisions
- Effect: All subdomains match (`assets.cdn.example.com`, `images.cdn.example.com`, etc.)

**Timeout behavior:**
- If no decision within 60 seconds, request auto-removed from queue
- Proxy returns 403 Forbidden with "Request timed out waiting for approval"
- UI shows notification: `â± Timed out: api.newservice.com`

### Common Workflows

**Allow a CDN with wildcards:**
1. Agent requests `assets.cdn.example.com`
2. Check âœ“ Apply to wildcard pattern
3. Click **Allow â†’ Project**
4. Result: `*.cdn.example.com` added to project patterns
5. Effect: All CDN subdomains allowed for this project

**Block an entire network:**
1. Agent requests `tracker.adnetwork.io`
2. Check âœ“ Apply to wildcard pattern
3. Click **Deny â†’ Global**
4. Result: `*.adnetwork.io` added to global denied patterns
5. Effect: All subdomains blocked across all projects

**Temporary debugging access:**
1. Agent requests `staging-api.newfeature.dev`
2. Leave wildcard unchecked
3. Click **Allow â†’ Session**
4. Result: Domain cached in memory for this cloister
5. Effect: Allowed until cloister stops, then forgotten

**One-time denial (don't cache):**
1. Agent requests `unknown-site.com`
2. Click **Deny â†’ Once**
3. Result: This request blocked, no persistence
4. Effect: Future requests will re-prompt for human decision

---

## Host Executor

TCP server on localhost (random port). The executor port is passed to the guardian container via `CLOISTER_EXECUTOR_PORT` environment variable. The guardian connects to `host.docker.internal:<port>` to send approved commands for execution on the host.

### Connection Model

Connection-per-request: guardian opens a new connection for each command, sends request, receives response, closes connection. This naturally multiplexes concurrent requests from different cloisters without request ID correlation.

```
Guardian                    Executor
   |                           |
   |--[connect]--------------->|
   |--{request JSON}\n-------->|  (goroutine spawned)
   |<--{response JSON}\n-------|
   |--[close]----------------->|
```

### Wire Format

Newline-delimited JSON (one object per line). Newlines within string values must be `\n` escaped.

### Execute Command

**Request:**
```json
{
    "secret": "e7f2a1b9c4d8...",
    "request": {
        "command": "docker",
        "args": ["compose", "up", "-d"],
        "workdir": "/home/user/repos/my-api",
        "env": {"DOCKER_HOST": "unix:///var/run/docker.sock"},
        "timeout_ms": 300000
    }
}
```

| Field | Required | Description |
|-------|----------|-------------|
| `secret` | Yes | Guardianâ†”executor shared secret |
| `request.command` | Yes | Executable name or path (no shell expansion) |
| `request.args` | No | Arguments array (default: empty) |
| `request.workdir` | No | Working directory for command execution |
| `request.env` | No | Environment overrides (merged with host environment) |
| `request.timeout_ms` | No | Execution timeout in milliseconds (default: 300000 = 5 min) |

**Validation order:**
1. Verify `secret` matches executor's secret â†’ reject if mismatch
2. Execute command via `exec` (no shell)

Token validation is handled by the guardian before forwarding requests to the executor. The executor trusts requests with valid shared secrets.

Using `command` + `args` instead of a shell command string prevents shell injection. If shell features are needed, the approved command must explicitly be `["sh", "-c", "..."]`.

**Response (success):**
```json
{
    "status": "completed",
    "exit_code": 0,
    "stdout": "Container my-api-db-1  Started\n",
    "stderr": ""
}
```

**Response (invalid secret):**
```json
{
    "status": "error",
    "error": "invalid secret"
}
```

**Response (timeout):**
```json
{
    "status": "timeout",
    "exit_code": -1,
    "stdout": "partial output...",
    "stderr": ""
}
```

**Response (execution error):**
```json
{
    "status": "error",
    "error": "exec: \"nonexistent\": executable file not found in $PATH"
}
```
