package cmd

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/spf13/cobra"

	"github.com/xdg/cloister/internal/config"
	"github.com/xdg/cloister/internal/prompt"
)

// oauthTokenPattern matches OAuth tokens in the format sk-ant-oaXXX...
var oauthTokenPattern = regexp.MustCompile(`sk-ant-oa[A-Za-z0-9_-]+`)

// AuthMethod represents the authentication method selected by the user.
type AuthMethod int

const (
	// AuthMethodToken uses a long-lived OAuth token.
	AuthMethodToken AuthMethod = iota
	// AuthMethodAPIKey uses an Anthropic API key.
	AuthMethodAPIKey
)

// String returns the config value for the auth method.
func (m AuthMethod) String() string {
	switch m {
	case AuthMethodToken:
		return "token"
	case AuthMethodAPIKey:
		return "api_key"
	default:
		return "unknown"
	}
}

// authMethodOptions are the options displayed to the user.
var authMethodOptions = []string{
	"Long-lived OAuth token (from `claude setup-token`) (recommended)",
	"API key (from console.anthropic.com)",
}

var setupClaudeCmd = &cobra.Command{
	Use:   "claude",
	Short: "Configure Claude Code authentication",
	Long: `Configure authentication for Claude Code inside cloister containers.

This wizard helps you set up one of two authentication methods:

  1. Long-lived OAuth token (recommended)
     Uses a token generated by 'claude setup-token'.
     The token is stored in cloister's config file.

  2. API key
     Uses an Anthropic API key from console.anthropic.com.
     The key is stored in cloister's config file.`,
	RunE: runSetupClaude,
}

// setupClaudePrompter is the prompter used by setup claude.
// It is set to the default StdinPrompter but can be overridden for testing.
var setupClaudePrompter prompt.Prompter

// setupClaudeCredentialReader is the credential reader used by setup claude.
// It can be overridden for testing.
var setupClaudeCredentialReader prompt.CredentialReader

// setupClaudeYesNoPrompter is the yes/no prompter used by setup claude.
// It can be overridden for testing.
var setupClaudeYesNoPrompter prompt.YesNoPrompter

// setupClaudeConfigLoader is the config loader used by setup claude.
// It can be overridden for testing.
var setupClaudeConfigLoader func() (*config.GlobalConfig, error)

// setupClaudeConfigWriter is the config writer used by setup claude.
// It can be overridden for testing.
var setupClaudeConfigWriter func(*config.GlobalConfig) error

// setupClaudeConfigPath is the function to get the config path.
// It can be overridden for testing.
var setupClaudeConfigPath func() string

// setupClaudeCommandRunner is the command runner used by setup claude.
// It can be overridden for testing.
var setupClaudeCommandRunner prompt.CommandRunner

func init() {
	setupCmd.AddCommand(setupClaudeCmd)
}

// getSetupClaudePrompter returns the prompter to use for setup claude.
// Uses stdin/stdout by default, but can be overridden via setupClaudePrompter.
func getSetupClaudePrompter(cmd *cobra.Command) prompt.Prompter {
	if setupClaudePrompter != nil {
		return setupClaudePrompter
	}
	return prompt.NewStdinPrompter(os.Stdin, cmd.OutOrStdout())
}

// getSetupClaudeCredentialReader returns the credential reader to use for setup claude.
// Uses terminal reader by default, but can be overridden via setupClaudeCredentialReader.
func getSetupClaudeCredentialReader(cmd *cobra.Command) prompt.CredentialReader {
	if setupClaudeCredentialReader != nil {
		return setupClaudeCredentialReader
	}
	return prompt.NewTerminalCredentialReader(os.Stdin, cmd.OutOrStdout())
}

// getSetupClaudeYesNoPrompter returns the yes/no prompter to use for setup claude.
// Uses stdin/stdout by default, but can be overridden via setupClaudeYesNoPrompter.
func getSetupClaudeYesNoPrompter(cmd *cobra.Command) prompt.YesNoPrompter {
	if setupClaudeYesNoPrompter != nil {
		return setupClaudeYesNoPrompter
	}
	return prompt.NewStdinYesNoPrompter(os.Stdin, cmd.OutOrStdout())
}

// getSetupClaudeConfigLoader returns the config loader to use for setup claude.
// Uses production implementation by default, but can be overridden for testing.
func getSetupClaudeConfigLoader() func() (*config.GlobalConfig, error) {
	if setupClaudeConfigLoader != nil {
		return setupClaudeConfigLoader
	}
	return config.LoadGlobalConfig
}

// getSetupClaudeConfigWriter returns the config writer to use for setup claude.
// Uses production implementation by default, but can be overridden for testing.
func getSetupClaudeConfigWriter() func(*config.GlobalConfig) error {
	if setupClaudeConfigWriter != nil {
		return setupClaudeConfigWriter
	}
	return config.WriteGlobalConfig
}

// getSetupClaudeConfigPath returns the config path getter to use for setup claude.
// Uses production implementation by default, but can be overridden for testing.
func getSetupClaudeConfigPath() func() string {
	if setupClaudeConfigPath != nil {
		return setupClaudeConfigPath
	}
	return config.GlobalConfigPath
}

// getSetupClaudeCommandRunner returns the command runner to use for setup claude.
// Uses production implementation by default, but can be overridden for testing.
func getSetupClaudeCommandRunner() prompt.CommandRunner {
	if setupClaudeCommandRunner != nil {
		return setupClaudeCommandRunner
	}
	return prompt.NewExecCommandRunner()
}

// credentialResult holds the credential data collected during setup.
type credentialResult struct {
	authMethod AuthMethod
	token      string // for AuthMethodToken
	apiKey     string // for AuthMethodAPIKey
}

// hasExistingCredentials checks if the config already has Claude credentials configured.
// Returns true if auth_method is set, or if token or api_key have values.
func hasExistingCredentials(cfg *config.GlobalConfig) bool {
	if cfg == nil || cfg.Agents == nil {
		return false
	}
	claudeCfg, ok := cfg.Agents["claude"]
	if !ok {
		return false
	}
	// Check if auth_method is set OR if token/api_key have values
	return claudeCfg.AuthMethod != "" || claudeCfg.Token != "" || claudeCfg.APIKey != ""
}

func runSetupClaude(cmd *cobra.Command, args []string) error {
	loadConfig := getSetupClaudeConfigLoader()
	yesNo := getSetupClaudeYesNoPrompter(cmd)

	// Check for existing credentials early
	cfg, err := loadConfig()
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	if hasExistingCredentials(cfg) {
		replace, err := yesNo.PromptYesNo("Credentials already configured. Replace? [y/N]: ", false)
		if err != nil {
			return fmt.Errorf("failed to get confirmation: %w", err)
		}
		if !replace {
			fmt.Fprintln(cmd.OutOrStdout(), "Setup canceled. Existing credentials unchanged.")
			return nil
		}
	}

	p := getSetupClaudePrompter(cmd)

	// Prompt for authentication method
	selection, err := p.Prompt("Select authentication method:", authMethodOptions, 0)
	if err != nil {
		return fmt.Errorf("failed to get authentication method: %w", err)
	}

	authMethod := AuthMethod(selection)

	// Display selected method
	fmt.Fprintf(cmd.OutOrStdout(), "\nSelected: %s\n", authMethodOptions[selection])
	fmt.Fprintf(cmd.OutOrStdout(), "Auth method: %s\n", authMethod.String())

	// Handle credential extraction based on auth method
	var creds credentialResult
	creds.authMethod = authMethod

	switch authMethod {
	case AuthMethodToken:
		token, err := handleTokenInput(cmd)
		if err != nil {
			return err
		}
		creds.token = token
	case AuthMethodAPIKey:
		apiKey, err := handleAPIKeyInput(cmd)
		if err != nil {
			return err
		}
		creds.apiKey = apiKey
	}

	// Prompt for skip-permissions setting
	skipPerms, err := handleSkipPermissionsPrompt(cmd)
	if err != nil {
		return err
	}

	// Display the result
	fmt.Fprintf(cmd.OutOrStdout(), "Skip permissions: %v\n", skipPerms)

	// Save credentials to config
	if err := saveCredentialsToConfig(cmd, creds, skipPerms); err != nil {
		return err
	}

	return nil
}

// saveCredentialsToConfig loads the global config, updates the claude agent
// settings with the provided credentials, and writes the config back.
func saveCredentialsToConfig(cmd *cobra.Command, creds credentialResult, skipPerms bool) error {
	loadConfig := getSetupClaudeConfigLoader()
	writeConfig := getSetupClaudeConfigWriter()
	getConfigPath := getSetupClaudeConfigPath()

	// Load existing config (or create default)
	cfg, err := loadConfig()
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Ensure agents map exists
	if cfg.Agents == nil {
		cfg.Agents = make(map[string]config.AgentConfig)
	}

	// Get existing claude config or create new one
	claudeCfg := cfg.Agents["claude"]

	// Update auth method
	claudeCfg.AuthMethod = creds.authMethod.String()

	// Clear any previous credentials when changing auth method
	claudeCfg.Token = ""
	claudeCfg.APIKey = ""

	// Set credentials based on auth method
	switch creds.authMethod {
	case AuthMethodToken:
		claudeCfg.Token = creds.token
	case AuthMethodAPIKey:
		claudeCfg.APIKey = creds.apiKey
	}

	// Update skip-permissions setting
	claudeCfg.SkipPerms = &skipPerms

	// Save back to config
	cfg.Agents["claude"] = claudeCfg

	// Write config
	if err := writeConfig(cfg); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	// Print success message
	configPath := getConfigPath()
	fmt.Fprintf(cmd.OutOrStdout(), "\nConfiguration saved to: %s\n", configPath)

	return nil
}

// handleTokenInput prompts for and reads a long-lived OAuth token.
// Offers to run `claude setup-token` automatically or allows manual input.
// Returns the token on success.
func handleTokenInput(cmd *cobra.Command) (string, error) {
	yesNo := getSetupClaudeYesNoPrompter(cmd)

	// Ask if the user wants to run claude setup-token automatically
	fmt.Fprintln(cmd.OutOrStdout())
	fmt.Fprintln(cmd.OutOrStdout(), "You can generate an OAuth token by running `claude setup-token`.")
	fmt.Fprintln(cmd.OutOrStdout(), "This will open your browser to authenticate with Anthropic.")
	fmt.Fprintln(cmd.OutOrStdout())

	runAuto, err := yesNo.PromptYesNo("Run `claude setup-token` automatically? [Y/n]: ", true)
	if err != nil {
		return "", fmt.Errorf("failed to get confirmation: %w", err)
	}

	if runAuto {
		return runClaudeSetupToken(cmd)
	}

	return handleManualTokenInput(cmd)
}

// runClaudeSetupToken runs `claude setup-token` and parses the OAuth token from output.
func runClaudeSetupToken(cmd *cobra.Command) (string, error) {
	runner := getSetupClaudeCommandRunner()

	fmt.Fprintln(cmd.OutOrStdout())
	fmt.Fprintln(cmd.OutOrStdout(), "Running `claude setup-token`...")
	fmt.Fprintln(cmd.OutOrStdout(), "Your browser will open for authentication. Please approve the request.")
	fmt.Fprintln(cmd.OutOrStdout())

	output, err := runner.Run("claude", "setup-token")
	if err != nil {
		fmt.Fprintf(cmd.OutOrStdout(), "Failed to run `claude setup-token`: %v\n", err)
		fmt.Fprintln(cmd.OutOrStdout())
		fmt.Fprintln(cmd.OutOrStdout(), "Falling back to manual token entry.")
		return handleManualTokenInput(cmd)
	}

	// Parse the OAuth token from the output
	token := parseOAuthToken(output)
	if token == "" {
		fmt.Fprintln(cmd.OutOrStdout(), "Could not find OAuth token in command output.")
		fmt.Fprintln(cmd.OutOrStdout())
		fmt.Fprintln(cmd.OutOrStdout(), "Command output:")
		fmt.Fprintln(cmd.OutOrStdout(), output)
		fmt.Fprintln(cmd.OutOrStdout())
		fmt.Fprintln(cmd.OutOrStdout(), "Falling back to manual token entry.")
		return handleManualTokenInput(cmd)
	}

	fmt.Fprintln(cmd.OutOrStdout(), "OAuth token obtained successfully.")
	return token, nil
}

// parseOAuthToken extracts an OAuth token (sk-ant-oa...) from command output.
func parseOAuthToken(output string) string {
	match := oauthTokenPattern.FindString(output)
	return match
}

// handleManualTokenInput prompts the user to manually paste their OAuth token.
func handleManualTokenInput(cmd *cobra.Command) (string, error) {
	reader := getSetupClaudeCredentialReader(cmd)

	fmt.Fprintln(cmd.OutOrStdout())
	fmt.Fprintln(cmd.OutOrStdout(), "To generate a token manually:")
	fmt.Fprintln(cmd.OutOrStdout(), "  1. Run: claude setup-token")
	fmt.Fprintln(cmd.OutOrStdout(), "  2. Approve the request in your browser")
	fmt.Fprintln(cmd.OutOrStdout(), "  3. Copy the token (starts with 'sk-ant-oa...')")
	fmt.Fprintln(cmd.OutOrStdout())

	token, err := reader.ReadCredential("Paste your OAuth token: ")
	if err != nil {
		return "", fmt.Errorf("failed to read OAuth token: %w", err)
	}

	token = strings.TrimSpace(token)
	if token == "" {
		return "", fmt.Errorf("OAuth token cannot be empty")
	}

	fmt.Fprintln(cmd.OutOrStdout(), "OAuth token received.")

	return token, nil
}

// handleAPIKeyInput prompts for and reads an Anthropic API key.
// Returns the API key on success.
func handleAPIKeyInput(cmd *cobra.Command) (string, error) {
	reader := getSetupClaudeCredentialReader(cmd)

	fmt.Fprintln(cmd.OutOrStdout())
	apiKey, err := reader.ReadCredential("Paste your API key (from console.anthropic.com): ")
	if err != nil {
		return "", fmt.Errorf("failed to read API key: %w", err)
	}

	apiKey = strings.TrimSpace(apiKey)
	if apiKey == "" {
		return "", fmt.Errorf("API key cannot be empty")
	}

	fmt.Fprintln(cmd.OutOrStdout(), "API key received.")

	return apiKey, nil
}

// handleSkipPermissionsPrompt prompts the user to enable or disable
// Claude's built-in permission prompts. Returns true to skip permissions
// (recommended inside cloister), false to keep them enabled.
func handleSkipPermissionsPrompt(cmd *cobra.Command) (bool, error) {
	yesNo := getSetupClaudeYesNoPrompter(cmd)

	fmt.Fprintln(cmd.OutOrStdout())
	skipPerms, err := yesNo.PromptYesNo("Skip Claude's built-in permission prompts? (recommended inside cloister) [Y/n]: ", true)
	if err != nil {
		return false, fmt.Errorf("failed to get skip-permissions setting: %w", err)
	}

	return skipPerms, nil
}
